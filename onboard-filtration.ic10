# manage a filtration unit via onboard chip slot
# stop filtering when outlet pressure hits the cap.
# also trigger when filters are missing or spent.
alias Self db
alias Light d0
alias Alarm d1
define FILTERS_EACH 4
define PRESSURE_TARGET 40000
alias ReturnValue r15
alias MaxSP r10
alias SlotNum r9
alias SlotZeroStatus r8
alias SlotOneStatus r7
init:
push HASH("ItemGasFilterCarbonDioxide")
push HASH("ItemGasFilterCarbonDioxideM")
push HASH("ItemGasFilterCarbonDioxideL")
push HASH("ItemGasFilterCarbonDioxideInfinite")
push LogicType.RatioCarbonDioxideInput
push HASH("ItemGasFilterNitrogen")
push HASH("ItemGasFilterNitrogenM")
push HASH("ItemGasFilterNitrogenL")
push HASH("ItemGasFilterNitrogenInfinite")
push LogicType.RatioNitrogenInput
push HASH("ItemGasFilterOxygen")
push HASH("ItemGasFilterOxygenM")
push HASH("ItemGasFilterOxygenL")
push HASH("ItemGasFilterOxygenInfinite")
push LogicType.RatioOxygenInput
push HASH("ItemGasFilterPollutants")
push HASH("ItemGasFilterPollutantsM")
push HASH("ItemGasFilterPollutantsL")
push HASH("ItemGasFilterPollutantsInfinite")
push LogicType.RatioPollutantInput
push HASH("ItemGasFilterVolatiles")
push HASH("ItemGasFilterVolatilesM")
push HASH("ItemGasFilterVolatilesL")
push HASH("ItemGasFilterVolatilesInfinite")
push LogicType.RatioVolatilesInput
push HASH("ItemGasFilterWater")
push HASH("ItemGasFilterWaterM")
push HASH("ItemGasFilterWaterL")
push HASH("ItemGasFilterWaterInfinite")
push LogicType.RatioSteamInput
push HASH("ItemGasFilterNitrousOxide")
push HASH("ItemGasFilterNitrousOxideM")
push HASH("ItemGasFilterNitrousOxideL")
push HASH("ItemGasFilterNitrousOxideInfinite")
push LogicType.RatioNitrousOxideInput
move MaxSP sp
s Self Mode 0
bdns Light skipLightInit
s Light On 0
skipLightInit:
bdns Alarm loop
s Alarm On 0
loop:
yield
l r0 Self PressureOutput
l r1 Self PressureOutput2
bgt r0 PRESSURE_TARGET stopFiltering
bgt r1 PRESSURE_TARGET stopFiltering
move SlotNum 0
jal checkFilterSlot
move SlotZeroStatus ReturnValue
move SlotNum 1
jal checkFilterSlot
move SlotOneStatus ReturnValue
seq r1 SlotZeroStatus -1 # slot 0 is empty
seq r2 SlotOneStatus -1 # slot 1 is empty
and r3 r1 r2 # both are empty
seqz r4 SlotZeroStatus # slot 0 is not good
seqz r5 SlotOneStatus # slot 1 is not good
or r6 r4 r5 # either slot is not good
seq r4 SlotZeroStatus 2
seq r5 SlotOneStatus 2
or r0 r4 r5
or r7 r3 r6 # stop if empty or filters invalid
or r7 r7 r0 # also stop when no target gas remains
or r6 r6 r3 # raise alert if both slots empty
bdns Light skipLightRun
s Light On r6
skipLightRun:
bdns Alarm skipAlarmRun
s Alarm On r6
skipAlarmRun:
bnez r7 stopFiltering
l r0 Self Mode
beqz r0 startFiltering
j loop
stopFiltering:
s Self Mode 0
j loop
startFiltering:
s Self Mode 1
j loop
checkFilterSlot: # slot:-1 empty,0 bad,1 ok,2 no gas
ls r0 Self SlotNum Occupied
select ReturnValue r0 0 -1 # ignore empty slots
beqz r0 ra
ls r0 Self SlotNum Quantity
move ReturnValue 0 # stop if filter is used up
beqz r0 ra
ls r0 Self SlotNum OccupantHash
move sp MaxSP
loopGasType:
pop r2 # gas logic type
move r4 0
loopFilters:
pop r3 # filter hash
seq r1 r0 r3
bnez r1 foundFilter
add r4 r4 1
blt r4 FILTERS_EACH loopFilters
blez sp noMatchedGasType
j loopGasType
noMatchedGasType:
move ReturnValue 0
j ra
foundFilter:
l r0 Self r2
sgtz r4 r0
move ReturnValue 1
beqz r4 noGas
j ra
noGas:
move ReturnValue 2
j ra
